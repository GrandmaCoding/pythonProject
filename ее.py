def FirstTask(some_string: str) -> None:#O(n) n = len(some_string) определение
    q = 0#O(1) присвоение  переменной
    n = ""#O(1) присвоение  переменной
    while(len(some_string) != len(n)):
        q += 1#O(1) бинарная операция
        n = some_string = some_string.replace("v", "")#O(1) присвоение O(n) - replace() (google инфа),replace выполнится ровно 1 раз, тк после данного присвоения n будет = somestring
#O(n) самая большая сложность



def SecondTask(some_string: str) -> None:#O(n) n = len(some_string) определение
    ord = {}#O(1) присвоение  переменной(создание пустого множества O(1))
    for ch in some_string:#O(n) - произойдет присвоение к переменной ch
        ord[ch] = some_string.count(ch)#O(1) - взятие элемента множества выполнется n раз => O(n),O(1) - взятие элемента словаря,
        # O(n^2): O(n) - count()  (google инфа) за одно выполнение, выполнется n раз => O(n^2)
#O(n^2) - самя большая сложность

def ThirdTask(some_string: str) -> None:#O(n) n = len(some_string) определение
    res = ""#O(1) присвоение  переменной
    for i in range(len(some_string)//2):#O(1) - range(функция вызовется 1 раз, O(1) - len(google инфа), O(n) - присвоение к i(вообще n//2, но тк 1/2 = constt => O(n)

        res = res + "\'" + some_string[i] + "\'"
        # O(n) - конкатинация строк - O(len(всех складываемых строк(гугл))) => общее время работы цикла равно сумме длин всех промежуточных строк
        # каждый раз будем брать 3 символа("\'" + some_string[i] + "\'") + данная длина res которая с каждой иттерацией будет расти на 1,
        # что по сути является алгебраической прогрессией, => S(n)=3⋅(1+2+3+⋯+ n/2), S(n) = 3*((n/2*(n/2 + 1))/2, S(n) = 3*n**2 / 8 => O(n**2) тк const нам не важны
    return res
#O(n**2) - самая большая сложность

def FourthTask(lst: list[int]):#O(n) n = len(some_string) определение
    return lst[0:len(lst)//2] == lst[len(lst)//2:]#O(n) - срезы проходят за длинны данного среза(n/2)(google info),
    #O(n) - сравнение двух списков происходит за общую длинну списков(n/2)(google info) но const нам не нужны

def FifthTask(lst: list[int]):#O(n) n = len(some_string) определение
    lst+=lst*5#O(n) - Создание нового списка требует времени пропорционального его длине(5n), O(n) - присвоение списка длинной 5n
#O(n) - самая большая сложность


def SixthTask(lst: list[int]):#O(n) n = len(some_string) определение
    for i in range(len(lst) - 1):#O(n) - присвоение к i, O(1) - range выполнится один раз
        lst.pop(1)# O(n^2) - удаление элемента из середины списка(самый худший вариант) n/2(const не важны так что n),
        # повторится n раз=> n^2
    return lst
#O(n^2) - самая большая сложность

#в следующий заданиях я не писал что некоторые операции находятся в цикле которые множат сложность
#так как это итак понятно
def SeventhTask(n: int):#O(1) присвоение  переменной
    i = n#O(1) присвоение  переменной
    s = ""#O(1) присвоение  переменной
    while i > 0:#O(n) - n/2 но конст нам не важны
        j = 1#O(1) присвоение  переменной
        while j < n:#O(nlog(n)) - выполняется по n раз
            k = 0#O(1) присвоение  переменной
            while k < n:#O(log(n))
                #внешний цикл выполняется log(n)
                #На каждой итерации внешнего цикла выполняется средний цикл со сложностью O(nlog(n))
                #общая сложность внешнего O((nlog(n))log(n)) => O(nlog(n)^2)
                k = k + 2#O(log(n)) за одну O(1) за все O(log(n))
                print(1)#O(log(n)) - log(1) за одну, за все O(log(n))
            j *= 2#O(nlog(n)) - O(1) за одну выполнится, всего будет nlog(n)
        i = i // 2#O(n) - O(1) за одну выполнится, всего будет n

#O(nlog(n)^2) - самая большая сложность

def EighthTask(n: int) -> (str, str):#O(1) присвоение  переменной
    for i in range(1, n):#O(n) - присвоение i, O(1) - range выполнится 1 раз
        for j in range(1, n, i):#O(n(сумма n-1 i=1 по функции 1/i)) примерно равная ln(n) присвоение i, O(n) - range тк в цикле
            print(1)

def NinthTask(some_string: str) -> None:#O(n) n = len(some_string) определение
    for i in range(len(some_string)):#O(n) - присвоение i, O(1) - len и range
        if some_string[i] == ' ':
            some_string.replace(' ', '', 1)#O(n^2) - каждый раз сложность уменьшается на 1 тк каждый
            # раз убираем символ => алгебраическая прогрессия = n*(n+1)/2 ~ n^2
#O(n^2) - самая большая сложность

def TenthTask(n: int) -> None:#O(1) присвоение  переменной
    q = 1#O(1) присвоение  переменной
    smth = 0#O(1) присвоение  переменной

    for i in range(n):#O(n) - присвоение i, O(1) - range
        if i > q:
            q *= 2
            for k in range(q):
                #Когда условие if i > q выполняется, внутренний цикл выполняется q раз
                #Общее количество итераций всех внутренних циклов можно записать как сумму геометрической прогрессии
                #2*(2^m -1) = O(2^(m+1)) ~ O(n)
                smth += 1#O(n) - одна O(1), но тк цикл выполнится n раз
#O(n) - самая большая сложность
def EleventhTask(lst: list[list[int]], n: int) -> bool:#O(n) - мы присваиваем список из n элементов
    # в каждом из которых 5 элементов => O(5n) => O(n)
    """
    Example of lst:
    [
        [1, 2, 5, 8, 11],
        [3, 4, 8, 10, 15],
        [5, 7, 9, 11, 16],
        [7, 10, 17, 19, 20]
    ]
    Look closely to the order of the items. This order is guaranteed for any input matrix.
    """
    n = len(lst)# O(1) — получение длины списка
    i, j = 0, n-1 # O(1) — инициализация
    while i < n and j >= 0:# Повторяется максимум n_rows + n_cols раз (O(n) для квадратной матрицы)
        if lst[i][j] == n:# O(1) — доступ по индексам
            return True
        elif lst[i][j] > n:
            j -= 1# O(1) — уменьшение
        else:
            i += 1# O(1) — увеличение
    return False
# Лучший случай:  O(1), если число находится в первой проверяемой ячейке.
# Худший случай:  O(n), где n — размер матрицы (n×n).
